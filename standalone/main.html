
<link rel="stylesheet" href="/static/css/jquery-ui.css">
<link rel="stylesheet" href="/static/css/bootstrap.min.css">
<link rel="stylesheet" href="/static/css/splash-blocks.css" rel="stylesheet" type="text/css">

<script src="/static/js/jquery.min.js"></script>
<script src="/static/js/jquery-ui.min.js"></script>
<script src="/static/js/bootstrap.min.js"></script>
<script src="/static/js/lodash.min.js"></script>

<script>
function d(what) {
	$("#debug_div").append(
		$("<p></p>").html(what)
	);
}

var splash = splash || {};	

splash.Util = {
	partial: function() {
		var fn = arguments[0];
		Array.prototype.shift.call(arguments);
		var args = Array.prototype.slice.call(arguments);
		return function() {
			var arg = 0;
			for ( var i = 0; i < args.length && arg < arguments.length; i++)
				if ( args[i] === undefined )
					args[i] = arguments[arg++];
			return fn.apply(this, args);
		};
	},
	inherits: function(subClass, superClass) {
		if (_.isFunction(subClass) && _.isFunction(superClass)) {
			subClass.prototype = _.create(superClass.prototype, {'constructor': subClass});
		} else {
			throw new Error('Only class definitions can inherit other class definitions.');
		}
	}
};

splash.Interpreter = {
	executeBlockChain: function(startingBlock, chainCallback) {
		startingBlock.codeSnippet.apply(this, startingBlock.args);
		
		if(startingBlock.nextBlockLink.child != undefined) {
			setTimeout(
				splash.Util.partial(splash.Interpreter.executeBlockChain, startingBlock.nextBlockLink.child, chainCallback),
				startingBlock.postExecutionDelay
			);
		}
		else if(chainCallback != undefined) {
			chainCallback();
		}
		//else do nothing... end of chain with no chain-callback defined.
	},
	runAllStripeBlocks: function(stripe) {
		_.forEach(stripe.firstLevelBlocks, function(startingBlock) {
			splash.Interpreter.executeBlockChain(startingBlock);
		});
	}
};





























splash.SpriteManager = {
	currentSprite: undefined,
	spriteList: [],
	setCurrentSprite: function(sprite) {
		this.currentSprite = sprite;
	},
	addSprite: function(sprite) {
		this.spriteList.push(sprite);
	},
	removeSprite: function(sprite) {
		var index = this.spriteList.indexOf(sprite);
		if(index != -1)
			spriteList.splice(index, 1);
	}
};












splash.BackgroundManager = {
	setBackground: function() {}
}














splash.Renderer = {
	renderBlockChain: function(startingBlock) {

		var currentBlock = startingBlock;

		while(true) {
			if(currentBlock.nextBlockLink.child == undefined) {
                break;
			}
			else {
				currentBlock.htmlElement.append(currentBlock.nextBlockLink.child.htmlElement);
				currentBlock.nextBlockLink.child.htmlElement.css({
					position: "relative"
				});

				currentBlock = currentBlock.nextBlockLink.child;
			}			
		}

		startingBlock.htmlElement.css({
			position: "absolute"
		});

		return startingBlock.htmlElement;
	}
};






splash.DragDropController = {
	currentDraggedBlock: {
		block: undefined,
		originalOffset: undefined,
		parentIsCanvas: undefined
	},
	unchainAndDrawDroppables: function(draggedBlock) {
		// Unchain
		if(draggedBlock.parentLink != undefined) {
			draggedBlock.removeParentLink();
		}
		else {
			// Temporarily remove draggedBlock from the firstLevelBlocks list
			splash.SpriteManager.currentSprite.removeFirstLevelBlock(draggedBlock);
		}

		// Record dragged block
		splash.DragDropController.currentDraggedBlock.block = draggedBlock;
		splash.DragDropController.currentDraggedBlock.originalOffset = _.clone(draggedBlock.htmlElement.offset());
		splash.DragDropController.currentDraggedBlock.parentIsCanvas = draggedBlock.htmlElement.parent().is(".canvas");

		// Set z-index
		draggedBlock.htmlElement.css({
			"z-index": 1000
		});

		// Draw droppables
		_.forEach(splash.SpriteManager.currentSprite.firstLevelBlocks, function(startingBlock) {
			var currentBlock = startingBlock;
			while(true) {
				if(currentBlock.nextBlockLink.child != undefined) {
					currentBlock = currentBlock.nextBlockLink.child;
					continue;
				}

				currentBlock.nextBlockLink.htmlElement.insertAfter(currentBlock.htmlElement.children(".block"));
				break;
			}
		});
	},

	cleanupAndClearDroppables: function(draggedBlock, event, ui) {
		// Note: the drop handler will fire first.

		// Set z-index
		draggedBlock.htmlElement.css({
			"z-index": "auto"
		});

		// Check if block was dropped on a snap area (and hence has a parent)
		if(draggedBlock.parentLink == undefined) {
			splash.SpriteManager.currentSprite.addFirstLevelBlock(draggedBlock);

			$(".canvas").append(draggedBlock.htmlElement);
			draggedBlock.htmlElement.css({
				position: "absolute",
			});

			if(!splash.DragDropController.currentDraggedBlock.parentIsCanvas) {
				draggedBlock.htmlElement.css({
					top: splash.DragDropController.currentDraggedBlock.originalOffset.top + ui.position.top - $(".canvas").offset().top,
					left: splash.DragDropController.currentDraggedBlock.originalOffset.left + ui.position.left - $(".canvas").offset().left,
				});
			}
		}

		// Remove record of dragged block
		splash.DragDropController.currentDraggedBlock.block = undefined;
		// splash.DragDropController.currentDraggedBlock.originalOffset = undefined;


		// Clear droppables
		$(".chain-snap-area").detach();
	},

	snapAreaDropHandler: function(dropAreaLink) {
		dropAreaLink.parent.setNextBlockLink(splash.DragDropController.currentDraggedBlock.block);
		dropAreaLink.parent.htmlElement.append(splash.DragDropController.currentDraggedBlock.block.htmlElement);
		splash.DragDropController.currentDraggedBlock.block.htmlElement.css({
			position: "relative",
			top: "auto",
			left: "auto"
		});
	}
};








splash.BlockLink = function(parent, child) {
	this.parent = parent; // this should _not_ change as each blocklink is tied permanently to a link (only child should change)
	this.child = child;
	this.htmlElement = this.render();
}

splash.BlockLink.prototype.render = function() {
	var htmlElement = $('<div class="chain-snap-area"></div>')
		.droppable({
			hoverClass: "drag-hover",
			tolerance: "pointer",
			drop: _.partial(splash.DragDropController.snapAreaDropHandler, this)
		});
    return htmlElement;
}
























splash.Block = function(parameters) {
	this.nextBlockLink = new splash.BlockLink(this);
	this.parentLink = undefined;
	this.args = {};

	if(_.isPlainObject(parameters)) {
		for(var i in parameters) {
			this[i] = parameters[i];
		}
	}

	this.htmlElement = this.render();
}

splash.Block.prototype.name = "Block";
splash.Block.prototype.expectedArgsCount = 0;
splash.Block.prototype.postExecutionDelay = 0;
splash.Block.prototype.codeSnippet = function() {};
splash.Block.prototype.render = function() {
    var htmlElement = $('<div class="block-drag-area"><div class="block"><div class="block-signature"><div class="block-name">' + this.name +'</div><div class="block-args"><input class="block-arg" placeholder="arg1" maxlength="3"><span>and</span><input class="block-arg" placeholder="arg2" maxlength="3"></div></div><div class="sub-blocks"><!-- nested blocks here --></div></div></div>')
    .draggable({
    	start: _.partial(splash.DragDropController.unchainAndDrawDroppables, this),
    	stop: _.partial(splash.DragDropController.cleanupAndClearDroppables, this)
    });
    return htmlElement;
};
// Sub-classes should not overwrite the following functions (i.e. "final methods")
splash.Block.prototype.setNextBlockLink = function(nextBlock) {
	this.nextBlockLink.child = nextBlock;
	nextBlock.parentLink = this.nextBlockLink; // the blocklink
}
splash.Block.prototype.getNextBlockLink = function() {
	return this.nextBlockLink.child;
}
splash.Block.prototype.removeParentLink = function() {
	this.parentLink.child = undefined;
	this.parentLink = undefined;
}






splash.Sprite = function(parameters) {
	this.firstLevelBlocks = [];

	if(_.isPlainObject(parameters)) {
		for(var i in parameters) {
			this[i] = parameters[i];
		}
	}
}

splash.Sprite.prototype.addFirstLevelBlock = function(block) {
	this.firstLevelBlocks.push(block);
}
splash.Sprite.prototype.removeFirstLevelBlock = function(block) {
	var index = this.firstLevelBlocks.indexOf(block);
		if(index != -1)
			this.firstLevelBlocks.splice(index, 1);
}












$(function() {
	$("html").on("mousemove", function(event) {
		$("#debug").html(
			event.pageX + ", " + event.pageY + "<br>"
		);
	})

	$(".canvas").droppable({
		tolerance: "pointer",
		drop: splash.DragDropController.canvasDropHandler
	});

	var newSprite = new splash.Sprite();
	splash.SpriteManager.addSprite(newSprite);

	splash.SpriteManager.setCurrentSprite(newSprite);
	var abc1 = new splash.Block({
		name: "abc1",
		codeSnippet: function() {
			console.log("hi1");
		}
	});
	var abc2 = new splash.Block({
		name: "abc2",
		codeSnippet: function() {
			console.log("hi2");
		}
	});
	var abc3 = new splash.Block({
	    name: "abc3",
	    codeSnippet: function() {
	        console.log("hi3");
	    }
	});
	var abc4 = new splash.Block({
	    name: "abc4",
	    codeSnippet: function() {
	        console.log("hi4");
	    }
	});

	abc1.setNextBlockLink(abc2);
	abc2.setNextBlockLink(abc3);

	newSprite.addFirstLevelBlock(abc1);
	newSprite.addFirstLevelBlock(abc4);

	$(".canvas").append(splash.Renderer.renderBlockChain(abc1));
	$(".canvas").append(splash.Renderer.renderBlockChain(abc4));

	goo = function() {
		splash.Interpreter.runAllStripeBlocks(newSprite);
	}
});


</script>
<div id="debug"></div>
<button onclick="goo()">Run</button>
<body><div class="canvas"></div></body>