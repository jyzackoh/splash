
<link rel="stylesheet" href="/static/css/jquery-ui.css">
<link rel="stylesheet" href="/static/css/bootstrap.min.css">
<link rel="stylesheet" href="/static/css/splash-blocks.css" rel="stylesheet" type="text/css">

<script src="/static/js/jquery.min.js"></script>
<script src="/static/js/jquery-ui.min.js"></script>
<script src="/static/js/bootstrap.min.js"></script>
<script src="/static/js/lodash.min.js"></script>

<script>
function d(what) {
	$("#debug_div").append(
		$("<p></p>").html(what)
	);
}

var splash = splash || {};	

splash.Util = {
	partial: function() {
		var fn = arguments[0];
		Array.prototype.shift.call(arguments);
		var args = Array.prototype.slice.call(arguments);
		return function() {
			var arg = 0;
			for ( var i = 0; i < args.length && arg < arguments.length; i++)
				if ( args[i] === undefined )
					args[i] = arguments[arg++];
			return fn.apply(this, args);
		};
	},
	inherits: function(subClass, superClass) {
		if (_.isFunction(subClass) && _.isFunction(superClass)) {
			subClass.prototype = _.create(superClass.prototype, {'constructor': subClass});
		} else {
			throw new Error('Only class definitions can inherit other class definitions.');
		}
	},
	parseParameters: function(that, parameters) {
		if(_.isPlainObject(parameters)) {
			for(var i in parameters) {
				that[i] = parameters[i];
			}
		}
	}
};

splash.Interpreter = {
	executeBlockChain: function(startingBlock, chainCallback) {
		startingBlock.codeSnippet.apply(this, startingBlock.args);
		
		if(startingBlock.nextBlockLink.child != undefined) {
			setTimeout(
				splash.Util.partial(splash.Interpreter.executeBlockChain, startingBlock.nextBlockLink.child, chainCallback),
				startingBlock.postExecutionDelay
			);
		}
		else if(chainCallback != undefined) {
			chainCallback();
		}
		//else do nothing... end of chain with no chain-callback defined.
	}
};

splash.Renderer = {
	renderBlockChain: function(startingBlock) {
		var currentBlock = startingBlock;
		var chainElement = currentBlock.htmlElement;

		while(true) {
			chainElement.append(currentBlock.htmlElement);
			chainElement.append("<br>");

			if(currentBlock.nextBlockLink.child == undefined) {
				chainElement.append(currentBlock.nextBlockLink.htmlElement);
                break;
			}
			else {
				currentBlock = currentBlock.nextBlockLink.child;
			}
		}

		return chainElement;
	},

	blockDragHelper: function(block) {
		if(block.parentLink != undefined) {
			block.htmlElement.insertBefore(block.parentLink.htmlElement);
            //TODO unlink the parent

            var currentBlock = block;
            var chainElement = $('<div class="chain"></div>');

            while(true) {
                chainElement.append(currentBlock.htmlElement);
                chainElement.append("<br>");
                
                if(currentBlock.nextBlockLink.child == undefined) {
                    currentBlock.nextBlockLink.htmlElement.detach();
                    break;
                }
                else {
                    currentBlock = currentBlock.nextBlockLink.child;
                }
            }

            return chainElement;
		}
        else {
            return block.htmlElement.parent();
        }
	}
};

splash.SpriteManager = {
	currentSprite: undefined,
	spriteList: [],
	setCurrentSprite: function() {},
	addSprite: function(sprite) {},
	removeSprite: function(sprite) {}
};

splash.BackgroundManager = {
	setBackground: function() {}
}

splash.BlockLink = function(parent, child) {
	this.parent = parent; // this should _not_ change as each blocklink is tied permanently to a link (only child should change)
	this.child = child;
	this.htmlElement = this.render();
}

splash.BlockLink.prototype.render = function() {
	var htmlElement = $('<div class="chain-snap-area"></div>')
		.droppable({
			hoverClass: "drag-hover"
			//drop: function() {...}
		});
    return htmlElement;
}


$(function() {
	splash.Interpreter.executeBlockChain(abc1);
	$("body").append(splash.Renderer.renderBlockChain(abc1));
});

/*

splash.ChildBlock = function(execute, args, expectedArgsCount, nextBlockLink) {
	splash.Block.apply(this, [execute, args, expectedArgsCount, nextBlockLink]);
}

// DUNNO WHAT I'M DOING FROM HERE ON
splash.ChildBlock.prototype = inherit(splash.Block.prototype);

//*/
</script>
<script src="/static/js/splash.js"></script>

<body></body>