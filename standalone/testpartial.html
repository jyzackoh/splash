
<link rel="stylesheet" href="/static/css/jquery-ui.css">
<link rel="stylesheet" href="/static/css/bootstrap.min.css">
<link rel="stylesheet" href="/static/css/splash-blocks.css" rel="stylesheet" type="text/css">

<script src="/static/js/jquery.min.js"></script>
<script src="/static/js/jquery-ui.min.js"></script>
<script src="/static/js/bootstrap.min.js"></script>
<script src="/static/js/lodash.min.js"></script>

<script>
function d(what) {
	$("#debug_div").append(
		$("<p></p>").html(what)
	);
}

var splash = splash || {};	

splash.Util = {
	partial: function() {
		var fn = arguments[0];
		Array.prototype.shift.call(arguments);
		var args = Array.prototype.slice.call(arguments);
		return function() {
			var arg = 0;
			for ( var i = 0; i < args.length && arg < arguments.length; i++)
				if ( args[i] === undefined )
					args[i] = arguments[arg++];
			return fn.apply(this, args);
		};
	},
	inherits: function(subClass, superClass) {
		if (_.isFunction(subClass) && _.isFunction(superClass)) {
			subClass.prototype = _.create(superClass.prototype, {'constructor': subClass});
		} else {
			throw new Error('Only class definitions can inherit other class definitions.');
		}
	}
};

splash.Interpreter = {
	executeBlockChain: function(startingBlock, chainCallback) {
		startingBlock.codeSnippet.apply(this, startingBlock.args);
		
		if(startingBlock.nextBlockLink.child != undefined) {
			setTimeout(
				splash.Util.partial(splash.Interpreter.executeBlockChain, startingBlock.nextBlockLink.child, chainCallback),
				startingBlock.postExecutionDelay
			);
		}
		else if(chainCallback != undefined) {
			chainCallback();
		}
		//else do nothing... end of chain with no chain-callback defined.
	}
};

splash.Renderer = {
	renderBlockChain: function(startingBlock) {
		var currentBlock = startingBlock;
		var chainElement = currentBlock.htmlElement;

		while(true) {
			chainElement.append(currentBlock.htmlElement);
			chainElement.append("<br>");

			if(currentBlock.nextBlockLink.child == undefined) {
				chainElement.append(currentBlock.nextBlockLink.htmlElement);
                break;
			}
			else {
				currentBlock = currentBlock.nextBlockLink.child;
			}
		}

		return chainElement;
	},

	blockDragHelper: function(block) {
		if(block.parentLink != undefined) {
			block.htmlElement.insertBefore(block.parentLink.htmlElement);
            //TODO unlink the parent

            var currentBlock = block;
            var chainElement = $('<div class="chain"></div>');

            while(true) {
                chainElement.append(currentBlock.htmlElement);
                chainElement.append("<br>");
                
                if(currentBlock.nextBlockLink.child == undefined) {
                    currentBlock.nextBlockLink.htmlElement.detach();
                    break;
                }
                else {
                    currentBlock = currentBlock.nextBlockLink.child;
                }
            }

            return chainElement;
		}
        else {
            return block.htmlElement.parent();
        }
	}
};

splash.SpriteManager = {
	currentSprite: undefined,
	spriteList: [],
	setCurrentSprite: function() {},
	addSprite: function(sprite) {},
	removeSprite: function(sprite) {}
};

splash.BackgroundManager = {
	setBackground: function() {}
}

splash.BlockLink = function(parent, child) {
	this.parent = parent; // this should _not_ change as each blocklink is tied permanently to a link (only child should change)
	this.child = child;
	this.htmlElement = this.render();
}

splash.BlockLink.prototype.render = function() {
	var htmlElement = $('<div class="chain-snap-area"></div>')
		.droppable({
			hoverClass: "drag-hover"
			//drop: function() {...}
		});
    return htmlElement;
}

splash.Block = function(parameters) {
	this.nextBlockLink = new splash.BlockLink(this);
	this.parentLink = undefined;
	this.args = {};
	this.htmlElement = this.render();

	if(_.isPlainObject(parameters)) {
		for(var i in parameters) {
			this[i] = parameters[i];
		}
	}
}

splash.Block.prototype.name = "Block";
splash.Block.prototype.expectedArgsCount = 0;
splash.Block.prototype.postExecutionDelay = 0;
splash.Block.prototype.codeSnippet = function() {};
splash.Block.prototype.render = function() {
    var htmlElement = $('<div class="chain"><div class="block"><div class="block-signature"><div class="block-name">Block Name</div><div class="block-args"><input class="block-arg" placeholder="arg1" maxlength="3"><span>and</span><input class="block-arg" placeholder="arg2" maxlength="3"></div></div><div class="sub-blocks"><!-- nested blocks here --></div></div></div>')
    .draggable({
        helper: _.partial(splash.Renderer.blockDragHelper, this),
        appendTo: "body"
    });
    return htmlElement;
};
// Sub-classes should not overwrite the following functions (i.e. "final methods")
splash.Block.prototype.setnextBlockLink = function(nextBlockLink) {
	this.nextBlockLink.child = nextBlockLink;
	nextBlockLink.parentLink = this.nextBlockLink; // the blocklink
}
splash.Block.prototype.getnextBlockLink = function() {
	return this.nextBlockLink.child;
}

splash.Sprite = function(parameters) {
	this.firstLevelBlocks = [];

	if(_.isPlainObject(parameters)) {
		for(var i in parameters) {
			this[i] = parameters[i];
		}
	}
}

splash.Block.prototype.addFirstLevelBlock = function(block) {
	this.firstLevelBlocks.push(block);
}
splash.Block.prototype.removeFirstLevelBlock = function(block) {
	for(var i = 0; i < firstLevelBlocks.length; i++) {
		if(this.firstLevelBlocks[i] == block) {
			this.firstLevelBlocks.splice(i, 1);
			return true;
		}
	}
	return false;
}

var abc1 = new splash.Block({
	name: "abc1",
	codeSnippet: function() {
		console.log("hi1");
	}
});
var abc2 = new splash.Block({
	name: "abc2",
	codeSnippet: function() {
		console.log("hi2");
	}
});
var abc3 = new splash.Block({
    name: "abc3",
    codeSnippet: function() {
        console.log("hi3");
    }
});

abc1.setnextBlockLink(abc2);
abc2.setnextBlockLink(abc3);

$(function() {
	splash.Interpreter.executeBlockChain(abc1);
	$("body").append(splash.Renderer.renderBlockChain(abc1));
});

/*

splash.ChildBlock = function(execute, args, expectedArgsCount, nextBlockLink) {
	splash.Block.apply(this, [execute, args, expectedArgsCount, nextBlockLink]);
}

// DUNNO WHAT I'M DOING FROM HERE ON
splash.ChildBlock.prototype = inherit(splash.Block.prototype);

//*/
</script>

<body></body>